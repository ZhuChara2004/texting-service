# frozen_string_literal: true

class MessageCreatorService
  def initialize(params)
    @params = params
  end

  def self.call(params)
    new(params).call
  end

  def call
    if phone_number_object.inactive?
      return {
        status: "error",
        message: "Phone number is inactive"
      }
    end

    # TODO: should we create messages if body is blank?
    # if same body is sent multiple times, we will create multiple messages to save historical data events
    message = phone_number_object.messages.create(body: @params[:message_body])

    if message
      SmsProviderRequestJob.perform_later(message, load_balanced_url)

      {
        status: "ok",
        message_id: message.reload.public_id, # reload is needed to get the public_id, generated by the database
      }
    else
      {
        status: "error",
        message: message.errors.full_messages.join(", ")
      }
    end
  # if exception is raised, we will return error message
  rescue => e
    {
      status: "error",
      message: e.message
    }
  end

  private

  def phone_number_object
    PhoneNumber.find_or_create_by(number: @params[:phone_number])
  end

  # It's a most simple and straightforward way to equally balance the load between providers.
  def load_balanced_url
    # This URLs list should be added to .env file
    ENV.fetch("SMS_PROVIDER_URLS", "https://example.com/prov1,https://example.com/prov2").split(",").sample
  end
end